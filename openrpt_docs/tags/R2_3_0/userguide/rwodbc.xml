<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<?xml-stylesheet href="docbook-omfg.css" type="text/css"?>
<chapter>
  <title id="i580465">OpenRPT and ODBC</title>

  <para>OpenRPT and its suite of tools enable you to connect natively to the
  PostgreSQL database. However, OpenRPT can also be used to connect to other
  databases using an ODBC (Open DataBase Connectivity) connection. In this
  chapter we will examine how to connect to an alternate database—for our
  example, an Access database—using ODBC. We will be showing you how to build
  a new report from the ground up, as we address the following steps:</para>

  <itemizedlist>
    <listitem>
      <para>Look at the Access database tables</para>
    </listitem>

    <listitem>
      <para>Configure settings for the ODBC connection</para>
    </listitem>

    <listitem>
      <para>Use the MetaSQL Editor to create the query</para>
    </listitem>

    <listitem>
      <para>Use OpenRPT to create the report definition</para>
    </listitem>

    <listitem>
      <para>Use the Report Renderer to view the report’s output</para>
    </listitem>
  </itemizedlist>

  <sect1>
    <title>The Access Database</title>

    <para>An Access database was chosen to demonstrate the ODBC connectivity
    capability of OpenRPT because it is widely used and easy to understand.
    The Contacts database used in the example is in fact one of the sample
    databases delivered with Access 2000. Below we see two of the tables we
    will be accessing throughout the example in this chapter:</para>

    <para><figure>
        <title>Contacts and Calls Tables in the Sample Access Database</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/ODBC_100_AccessTables.png" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>We will generate a report that connects to the Access database
    through ODBC, performs a SQL query that joins these two tables grouping
    all calls by caller, and displays each call’s duration, subject, and notes
    fields. The report output will look like this:</para>

    <para><figure>
        <title>Sample Report Generated with Report Renderer</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/ODBC_110_SampleOut.png" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>This report was generated using the Report Renderer (RPTRender) and
    a connection to the Access database using ODBC.</para>
  </sect1>

  <sect1>
    <title>Sample ODBC Connection</title>

    <para>It is important to keep in mind that ODBC drivers have differing
    levels of capability. For example, SQL written against one database using
    a specific driver may not function the same way when accessing the same
    database using an ODBC driver. OpenRPT was developed with a native
    connection to PostgreSQL. It can also connect to other databases using
    ODBC, but you should temper your expectations by the limitations of the
    ODBC driver you implement.</para>

    <para>Below we see the ODBC settings used to establish the connection to
    the Access database we will use throughout this chapter:</para>

    <para><figure>
        <title>ODBC Connection Settings</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/ODBC_120_Connection.png" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>The name of this connection is “contacts,” and as you will see, this
    is the reference we will use when connecting OpenRPT tools to the
    database. The connection also identifies the location and name of the
    Access database file (CONTACTS.MDB), which is the file that physically
    contains the database.</para>

    <note>
      <title>Note</title>

      <para>Some ODBC connections require database usernames and passwords for
      authentication. Authentication is implemented by the ODBC driver; not by
      OpenRPT.</para>
    </note>

    <para>The first step when creating any OpenRPT report is to create the
    report’s SQL. We will use the MetaSQL editor to accomplish this.</para>
  </sect1>

  <sect1>
    <title>Creating the Report’s SQL with the MetaSQL Editor</title>

    <para>In an earlier chapter you learned about the MetaSQL Editor and
    MetaSQL. In this section we will connect the MetaSQL Editor to our
    database using the ODBC connection ‘contacts’ and then craft the SQL we
    will use in the report’s definition.</para>

    <sect2>
      <title>Connecting Through the ODBC Driver</title>

      <para>Upon starting the MetaSQL Editor, we should next connect to the
      database by clicking the “File” drop down menu option. Next, select
      “Database” and finally “Connect”. You will see the standard OpenRPT
      connection screen:</para>

      <para><figure>
          <title>OpenRPT Connection Screen</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_130_MetaSQL_Connect.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Before proceeding, set the connection options by clicking on the
      OPTIONS button. You will see:</para>

      <para><figure>
          <title>Login Options for an ODBC Connection</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_140_MetaSQL_ConnectOptions.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>You will need to set the fields as follows:</para>

      <simpara>Driver: Select the ODBC option.</simpara>

      <simpara>Database: Enter the name you gave to your ODBC
      connection.</simpara>

      <simpara>Server: Leave blank. This is only used when connecting to
      PostgreSQL.</simpara>

      <simpara>Port: Leave blank. This only used when connecting to
      PostgreSQL.</simpara>

      <para>Click the SAVE button, and then on the Log In screen click the
      LOGIN button. Remember that the ODBC connection handles user
      authentication, so the “Username” and “Password” fields are normally not
      required when using this connection methodology.</para>
    </sect2>

    <sect2>
      <title>MetaSQL Parameters</title>

      <para>Earlier you learned about passing parameters to a report’s query
      using MetaSQL. For this report we will need two parameters: All_ID and
      Caller_ID. Use the drop-down menu option “Tools” and then “Parameter
      List” to create these two parameters:</para>

      <para><figure>
          <title>MetaSQL Parameters</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_150_MetaSQL_Params.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The values for the parameters are unimportant. As you will see in
      the query, just the existence of the All_ID parameter will cause the
      query to display data for all callers in the database.</para>
    </sect2>

    <sect2>
      <title>The Query</title>

      <para>Now we will create the query. Below is the SQL used in our
      query:</para>

      <programlisting>SELECT contacts.FirstName, contacts.LastName, calls.Subject, calls.Notes, calls.Duration
FROM calls, contacts
WHERE
&lt;? if exists("All_ID") ?&gt;
  contacts.ContactID = calls.ContactID
&lt;? elseif exists("Caller_ID") ?&gt; contacts.ContactID = &lt;? value("Caller_ID") ?&gt;
  AND contacts.ContactID = calls.ContactID
&lt;? endif ?&gt;
ORDER BY contacts.LastName;</programlisting>

      <para>This query joins the calls table and the contacts table on the
      contactID. The MetaSQL checks for the existence of the All_ID parameter.
      If it exists then the WHERE clause displays all calls. If the All_ID
      parameter does not exist then the WHERE clause displays all calls where
      the contacts.ContactID equals the value of the parameter
      Caller_ID.</para>

      <para>If we select the “Tools” drop down menu and click “Execute Query”
      we see:</para>

      <para><figure>
          <title>MetaSQL Results Output</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_160_MetaSQL_ExecQry.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <note>
        <title>Tip</title>

        <para>Remember that you can use the “View” menu option “Log Output” to
        troubleshoot your query.</para>
      </note>

      <para>Once we have a working query, we may save it to a text file by
      using the “File” menu option “Save As”. In the next section, we will
      Copy and Paste this SQL into the report definition’s Query
      Source.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Report Definition</title>

    <para>Now that we have a working query for our report, we will create the
    report’s definition. Again, you learned how to do this in previous
    chapters of this user guide.</para>

    <note>
      <title>Note</title>

      <para>The report definition we will be building introduces the Group
      section concept, which was not covered in depth in previous
      chapters.</para>
    </note>

    <para>We will begin by running OpenRPT. Note that OpenRPT opens
    automatically. It does not require authentication to a database. Unless
    your report definition resides in a PostgreSQL database (such as OpenMFG),
    you will save the reports locally as XML definition files.</para>

    <para>First let’s define our report’s Properties. Then we will create our
    Query Source with the SQL we validated using the MetaSQL editor. Next we
    will use the section editor to create our report’s sections. Then we will
    define the report’s parameters (we will use the ones tested with the
    MetaSQL editor and embedded in our query). And finally we will save our
    report to the XML definition file.</para>

    <sect2>
      <title>Report Properties</title>

      <para>Start a new report by selecting the “New” option from the “File”
      menu. Then, define the report’s Name, Title, and Description using the
      “Properties” option under the “Document” menus, as shown below:</para>

      <para><figure>
          <title>Report Properties</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_170_RptProps.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Click OK after defining the report’s Properties.</para>
    </sect2>

    <sect2>
      <title>Creating the Query Source</title>

      <para>Before proceeding to the next step, open the query you created in
      the last section using the MetaSQL Editor. Select the query and Copy it
      to the copy buffer. Then, in OpenRPT, use the “Document” drop down menu
      and select the “Query Sources” option. Click the ADD button and place
      your cursor in the Query portion of the screen. Right-click and paste
      your query here. In the Name field enter “detail”. When you are done the
      screen should look as follows:</para>

      <para><figure>
          <title>Query Source “detail” in OpenRPT Report Definition</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_180_QrySrc.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Click the OK button and CLOSE the Query List screen.</para>
    </sect2>

    <sect2>
      <title>Establishing Report Sections</title>

      <para>Earlier in the user guide you learned about report sections. Next
      we will activate our report’s sections. From the “Document” menu, select
      the “Section Editor” option. The following screen will appear:</para>

      <para><figure>
          <title>Initial Section Editor Settings</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_190_SectionEdNew.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Select the following options using your mouse:</para>

      <itemizedlist>
        <listitem>
          <para>Report Header</para>
        </listitem>

        <listitem>
          <para>Report Footer</para>
        </listitem>

        <listitem>
          <para>PageFooter, Any Page(s)</para>
        </listitem>

        <listitem>
          <para>Page Footer, Last Page</para>
        </listitem>
      </itemizedlist>

      <para>You’ll see later that we will leave the contents of the Page
      Footer, Last Page blank, as this will suppress the printing of the Page
      Footer, Any Page(s) so that only the Report Footer will print at the end
      of the report and we will not have a redundant section. This technique
      also applies to report headers, but not in this case as this report will
      contain only a Report Header and a Group Header, which we are about to
      define:</para>

      <para>From the Detail Sections display, select the “unnamed” Detail
      Section and click the EDIT button. Set the following:</para>

      <simpara>Section Name: Change to “group”.</simpara>

      <simpara>Query Source: Select the one you just entered called
      “detail”.</simpara>

      <simpara>Insert Page Break At End of Last Section: Leave unchecked. We
      will only have one section and will chose not to set a page
      break.</simpara>

      <simpara>Group Sections: Click the ADD button to add a new
      group</simpara>

      <para>You will now see a Group Section Editor screen that you will fill
      in with the following values as shown below:</para>

      <para><figure>
          <title>Group Section Editor</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_200_SectionGroup.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>A Group Section enables you to identify a Column in the query by
      which we will organize the display of the information. In this example
      we have call reports filed by several people. By grouping on the
      LastName column, we will have a report that organizes calls by caller.
      The options available to us include the following:</para>

      <simpara>Show Group Header: Creates a Group Header section. Frequently
      used to display the Column by which the report is grouped (in this case
      the caller’s last name) and report column descriptions.</simpara>

      <simpara>Show Group Footer: Creates a Group Footer section in which
      footer information, such as sub-total and total query results, may be
      displayed.</simpara>

      <simpara>Insert Page Break After the Footer: When selected, a page break
      is inserted between the end of one set of groups and the beginning of
      the next.</simpara>

      <para>Upon clicking OK on the Group Section Editor and then the Detail
      Section Properties screens, you will find that your Section Editor
      screen now has a Detail Section called “group”, as shown below:</para>

      <para><figure>
          <title>Section Editor Screen After Detail Section Added</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_210_SectionsEditor2.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Closing the Section Editor now returns you to the report’s layout.
      This will now include space for all of the sections you have created, as
      shown below:</para>

      <para><figure>
          <title>Sections Added to Report Definition</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_220_ReportSections.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The example shown above has been populated with the following
      information defined by section:</para>

      <simpara>Report Header: The report’s title and a line. This appears on
      the first page only.</simpara>

      <simpara>contact Group Header: This is the header for the group you just
      created called “contact”. It will display the caller’s first and last
      names from the query. Note that while the query may return many rows for
      a caller, the caller’s first and last name will be displayed only from
      the first row for each group. It will also display the column headers
      above each set of calls grouped by caller.</simpara>

      <simpara>group Detail: This section displays the rows returned for each
      caller. In the group header we display the caller’s name. Here we
      display the details for one or more calls made by this caller.</simpara>

      <simpara>contact Group Footer: The contents of this section display at
      the end of each set of calls for each caller.</simpara>

      <simpara>Report Footer: The Context Query called “page_number” is used
      here to display a page number on the bottom the last page of the
      report.</simpara>

      <simpara>Page Footer (Last): The next section is a Page Footer (any)
      which will put a page number on every page, including the Report
      Footer—which would be redundant if we take no action. A blank Page
      Footer (Last) serves to override the Page Footer (Any) with a blank
      footer on the last page so that the only page number displayed on this
      page is the one from the Report Footer.</simpara>

      <simpara>Page Footer (any): This places a page number on every page of
      the report. We suppress this on the last page of the report with a blank
      Page Footer (Last) so that only the Report Footer is used.</simpara>

      <para>Next we will define the parameters that will be used at run time
      when the report is generated with the Report Renderer.</para>
    </sect2>

    <sect2>
      <title>Defining Parameters</title>

      <para>For our example we will create two parameters. One of them, if
      present, will cause the report to display call information for all
      callers. The other enables the user to select a specific caller for whom
      to display information. We already identified these parameters when we
      created the report’s query using the MetaSQL Editor.</para>

      <para>To define parameters click on the “Document” menu and select the
      “Defined Parameters” option. Then click the ADD button to add a
      parameter called All_ID. Below is an example of the All_ID
      parameter:</para>

      <para><figure>
          <title>Static Parameter Example</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_230_Parameter1.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The information we entered for the All_ID parameter is explained
      below:</para>

      <simpara>Name: The name of the MetaSQL parameter as it appears in the
      report’s query.</simpara>

      <simpara>Type: The format of the parameter. The following formats are
      possible: String, Integer, Double, and Boolean.</simpara>

      <simpara>Active: Specifies whether the parameter is active by default at
      run time in the Report Renderer.</simpara>

      <simpara>Default: The default value for the parameter at run
      time.</simpara>

      <simpara>Description: A description of the parameter for use
      internally.</simpara>

      <simpara>Defined List: A static or dynamic list of options which the
      user may select from at run time. The All_ID parameter uses the static
      Defined List functionality.</simpara>

      <para>The next parameter, Caller_ID, uses the dynamic option for the
      Defined List capability:</para>

      <para id="i579620"><figure>
          <title>Dynamic Parameter Example</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_230_Parameter2.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <note>
        <title>Note</title>

        <para>A static Defined List enables you to define a discrete list of
        options which the user may chose from at run time. A dynamic Defined
        List utilizes a SQL query that is executed at run time so that the
        user can see a dynamic list of options.</para>
      </note>

      <para>In the example shown in <xref linkend="i579620" />, you can see
      the query we have entered will return the key value (i.e., ContactID) in
      the first column and the Last Name in the second column. Ultimately, the
      user will not see the ContactID. It is the second column that is the
      label the user can click on at run time to determine the value of the
      parameter sent to the report definition when the report output is
      generated.</para>

      <para>So, our Parameter List now includes two Parameters, as shown
      below:</para>

      <para><figure>
          <title>Parameter List</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_240_ParameterList.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>It is now time to save the report definition.</para>
    </sect2>

    <sect2>
      <title>Saving the Report’s XML Definition File</title>

      <para>To save a report definition for use with the Report Renderer,
      select the “Save As” option from the “File” menu. This will enable you
      to save the report definition in XML, which is the standard file format
      for OpenRPT report definitions.</para>

      <para><figure>
          <title>Saving Report Definition to XML Format</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_250_SaveAsXML.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <note>
        <title>Tip</title>

        <para>By saving to a shared drive you can easily make your reports
        available to others who have access to the Report Renderer.</para>
      </note>

      <para>Now that we have saved our report definition, we can close OpenRPT
      and use the Report Renderer to generate the report’s output.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Generating Reports with RPTRender</title>

    <para>RPTRender is a report rendering tool that enables users to open an
    OpenRPT report’s XML definition, select or edit parameter values, and then
    generate the report’s output.</para>

    <sect2>
      <title>Connecting Through ODBC to the Database</title>

      <para>The Report Renderer connection to the database through your ODBC
      connection works similarly to the connection you established with the
      MetaSQL Editor earlier in this chapter:</para>

      <para><figure>
          <title>Connecting Report Renderer with an ODBC Connection</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_260_RPTrenderConnect.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>To connect, simply click on the OPTIONS button, select ODBC under
      Driver, and then enter the name of the connection in the Database field.
      Click SAVE and then LOGIN. All other fields may be left blank.</para>
    </sect2>

    <sect2>
      <title>Opening the XML Report Definition</title>

      <para>From the Report Renderer main screen, select the “Open” option
      from the “File” menu to load the XML report definition:</para>

      <para><figure>
          <title>Report Loaded in Report Renderer</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_270_RPTrenderOpen.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>If we are satisfied with the parameter settings—which in this
      example means printing call detail for all callers—we can simply select
      the “Print” option from the “File” menu to generate the following
      report:</para>

      <para><figure>
          <title>Report Output for All Callers</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_280_CallOutput1_All.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>In the next section, we will see how it is possible to change the
      parameters and generate the report again.</para>
    </sect2>

    <sect2>
      <title>Setting Parameters at Run Time</title>

      <para>The MetaSQL for our report generates rows for all callers if the
      All_ID parameter exists. Its value is not a factor. In our next example,
      we want to generate a report for a single caller—not all callers. This
      means that at run time we will want to delete the All_ID parameter. To
      do this we must first click on it and then use the DELETE button.</para>

      <note>
        <title>Note</title>

        <para>Deleting a parameter at run time only deletes it temporarily—for
        the one time the report is being rendered. The parameter will still be
        present in the report’s XML definition the next time you open
        it.</para>
      </note>

      <para>Once the All_ID parameter has been temporarily removed, we will
      use the LIST button to select a specific caller for whom we want to
      generate the report.</para>

      <para id="i579967"><figure>
          <title>Setting the Caller_ID Parameter Value</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_290_ParamList.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>As you can see in <xref linkend="i579967" />, we have indicated we
      want to run a report on the caller named “Fuller.” We are now ready to
      print the report. The following shows the results we get:</para>

      <para><figure>
          <title>Report Output After Setting Dynamic Parameter’s Value</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_300_CallOutput2_Fuller.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>To generate this report we first created a connection to an ODBC
      data source, in this case an Access database. Then we used the OpenRPT
      MetaSQL editor to create the SQL Query source with MetaSQL parameters
      that enabled the user to specify all callers or a specific caller. We
      then used OpenRPT to create the report’s definition, in which we
      specified a group in the detail section to organize calls together by
      caller. We saved the definition to an XML definition file. Finally, we
      opened the XML report definition with the Report Renderer, set the
      embedded parameter values, and generated two versions of the report.
      This is the normal development cycle for an OpenRPT report.</para>
    </sect2>

    <sect2>
      <title>RPTRender Run Time Switches</title>

      <para>The Report Renderer supports switches that enable values to be
      passed to it at run time. These switches and a description of their use
      are provided below:</para>

      <simpara><synopsis>-databaseURL=</synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>Establishes the connection to the database:</para>
        </listitem>
      </itemizedlist>

      <simpara><synopsis>-databaseURL=odbc:///</synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>Contacts connects to the database through the ODBC connection
          called “contacts”</para>
        </listitem>
      </itemizedlist>

      <simpara><synopsis>-databaseURL=odbc:///</synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>Contacts connects to the database through the ODBC connection
          called “contacts”</para>
        </listitem>
      </itemizedlist>

      <simpara><synopsis>-noAuth</synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>Indicates that no username and password are required as is
          typically the case when this information is defined in the ODBC
          connection</para>
        </listitem>
      </itemizedlist>

      <simpara><synopsis>-username= </synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>The database username</para>
        </listitem>
      </itemizedlist>

      <simpara><synopsis>-passwd=</synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>The database user’s password</para>
        </listitem>
      </itemizedlist>

      <simpara><synopsis>-param=</synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>Establishes a parameter, its type and its value. For example
          -param=Caller_ID:string='3' establishes a parameter called Caller_ID
          of type string with a value of ‘3’. This example,
          -param=show_inactive:bool='Y' establishes a parameter called
          “showInactive” of type boolean with a value of ‘Y’</para>
        </listitem>
      </itemizedlist>

      <simpara><synopsis>-print</synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>The presence of this switch simply opens the operating
          system’s print dialogue immediately upon opening the Report
          Renderer</para>
        </listitem>
      </itemizedlist>

      <simpara><synopsis>-printerName=</synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>The value of this switch is the name of the printer that is
          selected automatically when the operating system’s print dialogue is
          opened. This example,<synopsis> -printerName="Laser6l"</synopsis>
          will automatically select the client computer’s printer with the
          name Laser6l.</para>
        </listitem>
      </itemizedlist>

      <simpara><synopsis>-close</synopsis></simpara>

      <itemizedlist>
        <listitem>
          <para>The presence of this switch simply closes the Report Renderer
          after the user prints or cancels printing.</para>
        </listitem>
      </itemizedlist>

      <note>
        <title>Tip</title>

        <para>When saving parameters to a report definition, the last position
        should contain the location and name of the OpenRPT report definition
        file. For example, on Windows this would look like this:</para>

        <para><synopsis>    c:\OpenMFG\Contacts-Calls-Report.xml</synopsis></para>
      </note>

      <para>Below are two examples of scripts that call the Report Renderer,
      passing to it switch settings for a specified report definition.</para>

      <para><figure>
          <title>Example of a Script that Connects to an ODBC Data
          Source</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_310_ExampleScriptODBC.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para><figure>
          <title>Example of a Script that Connect to a PostgreSQL Data
          Source</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ODBC_320_ExampleScriptPostgres.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The switches that the Report Renderer enables make it possible for
      you to store OpenRPT XML report definition files on a shared drive and
      script end user access to them for ad hoc reporting capability.</para>
    </sect2>
  </sect1>
</chapter>
